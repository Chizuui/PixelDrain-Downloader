name: Mirror (URL/Magnet/Torrent/Telegram) -> PixelDrain

on:
  workflow_dispatch:
    inputs:
      source:
        description: "Source Type (url | magnet | torrent_url | telegram)"
        required: true
        default: "magnet"
        type: choice
        options:
        - magnet
        - url
        - torrent_url
        - telegram
      input:
        description: "Link / Magnet / File ID"
        required: true
      filename:
        description: "Custom filename (Only for direct URL/Telegram)"
        required: false
        default: ""

jobs:
  mirror:
    runs-on: ubuntu-latest
    steps:
      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y aria2 curl jq python3

      - name: Prepare variables
        id: vars
        shell: bash
        run: |
          SRC="${{ inputs.source }}"
          INP="${{ inputs.input }}"
          CUSTOM="${{ inputs.filename }}"

          # Default output filename logic for single files
          AUTO="download.bin"
          if [ "$SRC" = "url" ]; then
            AUTO="$(basename "${INP%%\?*}")"
            [ -z "$AUTO" ] && AUTO="download.bin"
          elif [ "$SRC" = "telegram" ]; then
            AUTO="telegram_download.bin"
          fi

          FILE="${CUSTOM:-$AUTO}"

          echo "src=$SRC" >> "$GITHUB_OUTPUT"
          echo "inp=$INP" >> "$GITHUB_OUTPUT"
          echo "file=$FILE" >> "$GITHUB_OUTPUT"

      # =========================================
      # DOWNLOAD STEPS
      # =========================================

      # 1. Direct URL
      - name: Download direct URL
        if: steps.vars.outputs.src == 'url'
        shell: bash
        run: |
          URL="${{ steps.vars.outputs.inp }}"
          FILE="${{ steps.vars.outputs.file }}"
          aria2c --max-connection-per-server=16 --split=16 --min-split-size=1M \
            --user-agent="Mozilla/5.0" -o "$FILE" "$URL"

      # 2. Magnet Link
      - name: Download Magnet
        if: steps.vars.outputs.src == 'magnet'
        shell: bash
        run: |
          MAGNET="${{ steps.vars.outputs.inp }}"
          mkdir -p out
          # Optimized aria2c for torrents
          aria2c --seed-time=0 --bt-stop-timeout=60 --enable-dht=true \
            --follow-torrent=mem -d out "$MAGNET"
          
          echo "Download finished. Content of out:"
          ls -R out

      # 3. Torrent File URL
      - name: Download Torrent URL
        if: steps.vars.outputs.src == 'torrent_url'
        shell: bash
        run: |
          TORRENT_URL="${{ steps.vars.outputs.inp }}"
          mkdir -p out
          curl -L --fail -o file.torrent "$TORRENT_URL"
          aria2c --seed-time=0 --bt-stop-timeout=60 -d out file.torrent

      # 4. Telegram
      - name: Download from Telegram
        if: steps.vars.outputs.src == 'telegram'
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_INPUT: ${{ steps.vars.outputs.inp }}
          OUTFILE: ${{ steps.vars.outputs.file }}
        shell: bash
        run: |
          if [ -z "$TELEGRAM_BOT_TOKEN" ]; then
            echo "::error::Missing TELEGRAM_BOT_TOKEN"
            exit 1
          fi
          python3 << 'PY'
          import json, os, re, sys, urllib.request, urllib.parse
          token = os.environ["TELEGRAM_BOT_TOKEN"]
          inp = os.environ["TELEGRAM_INPUT"].strip()
          out = os.environ["OUTFILE"]

          def api_get(url):
              with urllib.request.urlopen(url) as r:
                  return json.loads(r.read().decode("utf-8"))

          # Logic to find file_id from message or input
          file_id = None
          if len(inp) > 20 and "/" not in inp:
              file_id = inp
          else:
              updates = api_get(f"https://api.telegram.org/bot{token}/getUpdates")
              if not updates.get("ok"): sys.exit(1)
              # Simple logic: take last message with document/video
              for u in reversed(updates.get("result", [])):
                  msg = u.get("message") or u.get("channel_post") or {}
                  for k in ["document", "video", "audio"]:
                      if k in msg:
                          file_id = msg[k]["file_id"]
                          break
                  if file_id: break

          if not file_id:
              print("No file found.")
              sys.exit(1)

          info = api_get(f"https://api.telegram.org/bot{token}/getFile?file_id={file_id}")
          path = info["result"]["file_path"]
          dl_url = f"https://api.telegram.org/file/bot{token}/{path}"
          print(f"Downloading: {dl_url}")
          urllib.request.urlretrieve(dl_url, out)
          PY

      # =========================================
      # UPLOAD STEPS (FIXED)
      # =========================================
      - name: Upload to PixelDrain
        env:
          PIXELDRAIN_API_KEY: ${{ secrets.PIXELDRAIN_API_KEY }}
        shell: bash
        run: |
          SRC="${{ steps.vars.outputs.src }}"
          SINGLE_FILE="${{ steps.vars.outputs.file }}"
          
          if [ -z "$PIXELDRAIN_API_KEY" ]; then
            echo "::error::Missing PIXELDRAIN_API_KEY"
            exit 1
          fi

          echo "## üì§ PixelDrain Upload Results" >> "$GITHUB_STEP_SUMMARY"
          echo "| File Name | Size | Link |" >> "$GITHUB_STEP_SUMMARY"
          echo "| :--- | :--- | :--- |" >> "$GITHUB_STEP_SUMMARY"

          # Function to upload a single file safely
          upload_file() {
            local fpath="$1"
            local fname="$(basename "$fpath")"
            
            echo "üöÄ Uploading: $fname"
            
            # CRITICAL FIX: Added -g to curl to disable globbing (fixes brackets error)
            RESP="$(curl -g -sS -u :$PIXELDRAIN_API_KEY -T "$fpath" -n https://pixeldrain.com/api/file/)"
            
            ID="$(echo "$RESP" | jq -r '.id // empty')"
            SIZE="$(echo "$RESP" | jq -r '.size // empty')"
            
            if [ -n "$ID" ]; then
              LINK="https://pixeldrain.com/u/$ID"
              echo "‚úÖ Uploaded: $LINK"
              echo "| \`$fname\` | $SIZE | [Download]($LINK) |" >> "$GITHUB_STEP_SUMMARY"
            else
              echo "‚ùå Error uploading $fname: $RESP"
            fi
          }

          # Logic: If 'out' folder exists (Torrent/Magnet), upload contents recursively
          if [ -d "out" ]; then
             # Find all files in 'out', handle spaces correctly
             find out -type f -print0 | while IFS= read -r -d '' file; do
               upload_file "$file"
             done
          # Else: Upload the single downloaded file (URL/Telegram)
          elif [ -f "$SINGLE_FILE" ]; then
             upload_file "$SINGLE_FILE"
          else
             echo "::error::No file found to upload!"
             exit 1
          fi
