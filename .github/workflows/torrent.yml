name: Mirror (Telegram/Torrent/Magnet/URL) -> PixelDrain

on:
  workflow_dispatch:
    inputs:
      source:
        description: "url | magnet | torrent_url | telegram"
        required: true
        default: "telegram"
      input:
        description: "Direct URL / magnet / URL .torrent / (Telegram: file_id atau link t.me)"
        required: true
      filename:
        description: "Optional custom filename"
        required: false
        default: ""

jobs:
  mirror:
    runs-on: ubuntu-latest
    steps:
      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y aria2 curl jq python3 zip

      - name: Prepare variables
        id: vars
        shell: bash
        run: |
          SRC="${{ inputs.source }}"
          INP="${{ inputs.input }}"
          CUSTOM="${{ inputs.filename }}"

          AUTO="download.bin"
          if [ "$SRC" = "url" ]; then
            AUTO="$(basename "${INP%%\?*}")"
          elif [ "$SRC" = "magnet" ]; then
            AUTO="magnet_download"
          elif [ "$SRC" = "torrent_url" ]; then
            AUTO="torrent_download"
          elif [ "$SRC" = "telegram" ]; then
            AUTO="telegram_download.bin"
          fi

          FILE="${CUSTOM:-$AUTO}"

          echo "src=$SRC" >> $GITHUB_OUTPUT
          echo "inp=$INP" >> $GITHUB_OUTPUT
          echo "file=$FILE" >> $GITHUB_OUTPUT

      # ===== DIRECT URL =====
      - name: Download direct URL
        if: steps.vars.outputs.src == 'url'
        run: |
          aria2c -o "${{ steps.vars.outputs.file }}" "${{ steps.vars.outputs.inp }}"
          ls -lh "${{ steps.vars.outputs.file }}"

      # ===== MAGNET =====
      - name: Download magnet
        if: steps.vars.outputs.src == 'magnet'
        run: |
          mkdir -p out
          aria2c --seed-time=0 --follow-torrent=mem --bt-stop-timeout=60 -d out "${{ steps.vars.outputs.inp }}"
          ls -lah out

      # ===== TORRENT URL =====
      - name: Download torrent file URL
        if: steps.vars.outputs.src == 'torrent_url'
        run: |
          mkdir -p out
          curl -L --fail -o file.torrent "${{ steps.vars.outputs.inp }}"
          aria2c --seed-time=0 -d out file.torrent
          ls -lah out

      # ===== TELEGRAM (gabungan: file_id atau link t.me -> ambil media terbaru dari getUpdates) =====
      - name: Download from Telegram (file_id OR t.me link)
        if: steps.vars.outputs.src == 'telegram'
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_INPUT: ${{ steps.vars.outputs.inp }}
          OUTFILE: ${{ steps.vars.outputs.file }}
        shell: bash
        run: |
          if [ -z "$TELEGRAM_BOT_TOKEN" ]; then
            echo "Missing TELEGRAM_BOT_TOKEN"
            exit 1
          fi

          python3 << 'PY'
          import json, os, re, sys, urllib.request, urllib.parse

          token = os.environ["TELEGRAM_BOT_TOKEN"]
          inp = os.environ["TELEGRAM_INPUT"].strip()
          out = os.environ["OUTFILE"]

          def api_get(url: str):
            with urllib.request.urlopen(url) as r:
              return json.loads(r.read().decode("utf-8"))

          def pick_file_id_from_update(obj: dict):
            """
            Prioritas: document/video/audio; fallback: photo (ambil ukuran terbesar)
            """
            # message or channel_post
            msg = obj.get("message") or obj.get("channel_post") or {}
            if "document" in msg and "file_id" in msg["document"]:
              return ("document", msg["document"]["file_id"])
            if "video" in msg and "file_id" in msg["video"]:
              return ("video", msg["video"]["file_id"])
            if "audio" in msg and "file_id" in msg["audio"]:
              return ("audio", msg["audio"]["file_id"])
            if "photo" in msg and isinstance(msg["photo"], list) and msg["photo"]:
              # ambil yang terakhir (biasanya terbesar)
              ph = msg["photo"][-1]
              if "file_id" in ph:
                return ("photo", ph["file_id"])
            return (None, None)

          # Case 1: input sudah berupa file_id (bukan URL t.me)
          is_tme = bool(re.match(r"^https?://t\.me/|^t\.me/", inp))
          is_file_id_like = (not is_tme) and (len(inp) >= 20) and ("/" not in inp) and (" " not in inp)

          file_id = None

          if is_file_id_like:
            file_id = inp
            mode = "direct_file_id"
          else:
            # Case 2: input adalah t.me link (atau bukan file_id)
            # -> Bot API tidak bisa fetch message dari link t.me
            # -> solusi: user FORWARD pesan/file itu ke bot, lalu kita ambil media TERBARU dari getUpdates
            mode = "latest_update_media"

            updates = api_get(f"https://api.telegram.org/bot{token}/getUpdates")
            if not updates.get("ok"):
              print("getUpdates failed:", updates)
              sys.exit(1)

            results = updates.get("result", [])
            # cari update paling terakhir yang punya media
            results_sorted = sorted(results, key=lambda x: x.get("update_id", 0), reverse=True)

            for u in results_sorted:
              kind, fid = pick_file_id_from_update(u)
              if fid:
                file_id = fid
                picked_kind = kind
                picked_update_id = u.get("update_id")
                break

            if not file_id:
              print("Tidak menemukan media terbaru di getUpdates.")
              print("Kalau input kamu link t.me, FORWARD dulu pesan/file itu ke bot, lalu jalankan workflow lagi.")
              sys.exit(1)

            print(f"Picked from getUpdates: kind={picked_kind}, update_id={picked_update_id}")

          # resolve file_path
          url = f"https://api.telegram.org/bot{token}/getFile?file_id={urllib.parse.quote(file_id)}"
          info = api_get(url)
          if not info.get("ok"):
            print("getFile failed:", info)
            sys.exit(1)

          path = info["result"]["file_path"]
          dl = f"https://api.telegram.org/file/bot{token}/{path}"

          print("Mode:", mode)
          print("Downloading:", dl)
          urllib.request.urlretrieve(dl, out)
          print("Saved:", out)
          PY

          ls -lh "$OUTFILE"

      # ===== SELECT UPLOAD TARGET =====
      - name: Prepare upload file
        id: pick
        run: |
          if [ "${{ steps.vars.outputs.src }}" = "magnet" ] || [ "${{ steps.vars.outputs.src }}" = "torrent_url" ]; then
            zip -r torrent_payload.zip out
            echo "target=torrent_payload.zip" >> $GITHUB_OUTPUT
          else
            echo "target=${{ steps.vars.outputs.file }}" >> $GITHUB_OUTPUT
          fi
          ls -lh "${{ steps.pick.outputs.target }}"

      # ===== PIXELDRAIN =====
      - name: Upload to PixelDrain
        env:
          PIXELDRAIN_API_KEY: ${{ secrets.PIXELDRAIN_API_KEY }}
        run: |
          FILE="${{ steps.pick.outputs.target }}"

          if [ -z "$PIXELDRAIN_API_KEY" ]; then
            echo "Missing PIXELDRAIN_API_KEY"
            exit 1
          fi

          RESP=$(curl -sS -u :$PIXELDRAIN_API_KEY -T "$FILE" https://pixeldrain.com/api/file/)
          echo "$RESP" | jq . || echo "$RESP"

          ID=$(echo "$RESP" | jq -r '.id // empty')
          if [ -z "$ID" ]; then
            echo "PixelDrain upload failed (missing id)"
            exit 1
          fi

          echo "## PixelDrain" >> $GITHUB_STEP_SUMMARY
          echo "- File: \`$FILE\`" >> $GITHUB_STEP_SUMMARY
          echo "- Link: https://pixeldrain.com/u/$ID" >> $GITHUB_STEP_SUMMARY

      - name: Done
        run: echo "Mirror selesai âœ…"
